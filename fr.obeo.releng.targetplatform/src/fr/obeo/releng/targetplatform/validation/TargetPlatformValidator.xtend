/*
 * generated by Xtext
 */
package fr.obeo.releng.targetplatform.validation

import com.google.common.collect.Multimaps
import com.google.common.collect.Sets
import com.google.inject.Inject
import fr.obeo.releng.targetplatform.targetplatform.IU
import fr.obeo.releng.targetplatform.targetplatform.Location
import fr.obeo.releng.targetplatform.targetplatform.Option
import fr.obeo.releng.targetplatform.targetplatform.TargetPlatform
import fr.obeo.releng.targetplatform.targetplatform.TargetplatformPackage
import fr.obeo.releng.targetplatform.util.LocationIndexBuilder
import java.util.List
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.nodemodel.impl.CompositeNode
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.scoping.impl.ImportUriResolver
import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TargetPlatformValidator extends AbstractTargetPlatformValidator {

	@Inject
	ImportUriResolver resolver;
	
	val LocationIndexBuilder indexBuilder;

	public static val CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED = "CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED"
	
	public static val CHECK__OPTIONS_EQUALS_ALL_LOCATIONS = "CHECK__OPTIONS_EQUALS_ALL_LOCATIONS"
	public static val CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS = "CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS"
	
	public static val DEPRECATE__OPTIONS_ON_LOCATIONS = "DEPRECATE__OPTIONS_ON_LOCATIONS"
	public static val DEPRECATE__STRINGS_ON_IU_VERSION = "DEPRECATE__STRINGS_ON_IU_VERSION"
	
	public static val CHECK__LOCATION_CONFLICTUAL_ID = "CHECK__LOCATION_CONFLICTUAL_ID"
	public static val CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID = "CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID"	
	
	new() {
		indexBuilder = new LocationIndexBuilder(resolver)
	}
	
	@Check
	def checkAllEnvAndRequiredAreSelfExluding(TargetPlatform targetPlatform) {
		doCheckAllEnvAndRequiredAreSelfExluding(targetPlatform, targetPlatform.options, TargetplatformPackage.Literals.TARGET_PLATFORM__OPTIONS);
	}
	
	def doCheckAllEnvAndRequiredAreSelfExluding(EObject optionOwner, List<Option> options, EStructuralFeature feature) {
		if (options.contains(Option.INCLUDE_ALL_ENVIRONMENTS) && options.contains(Option.INCLUDE_REQUIRED)) {
			error("All environments can not be included along with required artifacts, you must choose one of the two options.", 
					optionOwner, 
					feature, 
					options.indexOf(Option.INCLUDE_REQUIRED), CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED)
			
			error("All environments can not be included along with required artifacts, you must choose one of the two options.", 
					optionOwner, 
					feature, 
					options.indexOf(Option.INCLUDE_ALL_ENVIRONMENTS), CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED)
		}
	}
	
	@Check
	def noLocationOptionIfGlobalOptions(Location location) {
		if (!location.options.empty && !(location.eContainer as TargetPlatform).options.empty) {
			val nodes = NodeModelUtils::findNodesForFeature(location, TargetplatformPackage.Literals.LOCATION__OPTIONS)
			val withKeyword = (nodes.head as CompositeNode).previousSibling
			val lastOption = (nodes.last as CompositeNode);
			acceptError("You can not define options on location and on target platform.",
				location, withKeyword.offset, lastOption.endOffset - withKeyword.offset, CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS)
		}
	}
	
	@Check
	def checkOptionsOnLocationAreIdentical(TargetPlatform targetPlatform) {
		if (targetPlatform.options.empty) { // else do not check as it is another error.
			val listOptions = targetPlatform.locations
			val first = listOptions.head
			val conflicts = listOptions.tail.filter[_| !Sets::symmetricDifference(_.options.toSet,first.options.toSet).empty]
			if (!conflicts.empty) {
				listOptions.forEach[_ |
					val nodes = NodeModelUtils::findNodesForFeature(_, TargetplatformPackage.Literals.LOCATION__OPTIONS)
					if (!nodes.empty) {
						val withKeyword = (nodes.head as CompositeNode).previousSibling
						val lastOption = (nodes.last as CompositeNode)
						acceptError("Options of every locations must be the same",
							_, withKeyword.offset, lastOption.endOffset - withKeyword.offset, CHECK__OPTIONS_EQUALS_ALL_LOCATIONS)
					} else {
						val node = NodeModelUtils::getNode(_)
						acceptError("Options of every locations must be the same",
							_, node.offset, node.length, CHECK__OPTIONS_EQUALS_ALL_LOCATIONS)
					}
				]
			}
		}
	}
	
	@Check
	def checkAllEnvAndRequiredAreSelfExluding(Location location) {
		doCheckAllEnvAndRequiredAreSelfExluding(location, location.options, TargetplatformPackage.Literals.LOCATION__OPTIONS)
	}
	
	@Check
	def deprecateOptionsOnLocation(Location location) {
		val targetPlatform = location.eContainer as TargetPlatform
		
		if (targetPlatform.options.empty) {
			val nodes = NodeModelUtils::findNodesForFeature(location, TargetplatformPackage.Literals.LOCATION__OPTIONS)
			val withKeyword = (nodes.head as CompositeNode).previousSibling
			val lastOption = (nodes.last as CompositeNode);
			acceptWarning("Options on location are deprecated. Define the option at the target level.",
				location, withKeyword.offset, lastOption.endOffset - withKeyword.offset, DEPRECATE__OPTIONS_ON_LOCATIONS)
		}
	}
	
	@Check
	def deprecateIUVersionRangeWihString(IU iu) {
		if (iu.version != null) {
			val nodes = NodeModelUtils::findNodesForFeature(iu, TargetplatformPackage.Literals.IU__VERSION)
			if ("STRING".equals((nodes.head.grammarElement as RuleCall).rule.name)) {
				warning("Usage of strings is deprecated for version range. You should remove the quotes.",
					iu, 
					TargetplatformPackage.Literals.IU__VERSION,
					DEPRECATE__STRINGS_ON_IU_VERSION)
			}
		}
	}
	
	@Check
	def checkIDUniqueOnAllLocations(TargetPlatform targetPlatform) {
		val index = indexBuilder.getLocationIndex(targetPlatform)
		val resource = targetPlatform.eResource
		
		val conflictualURI = index.keySet.map[
			index.get(it).filter[ID != null].map[ID].toSet
		].filter[
			size > 1
		]
		
		if (conflictualURI.empty) {
			val uniqueLocation = Multimaps.index(
				index.keySet.map[index.get(it).filter[ID != null].head].filterNull,
				[ID]
			)
			uniqueLocation.keys
			val duplicateIDLocation = uniqueLocation.keys.filter[uniqueLocation.keys.count(it) > 1]
			duplicateIDLocation.forEach[
				uniqueLocation.get(it).forEach[duplicateID |
				val allNonUniqIDLocations = index.get(duplicateID.uri);
				val external = allNonUniqIDLocations.filter[resource != eResource];
				val internal = allNonUniqIDLocations.filter[resource == eResource];
				
				internal.forEach[
					error('ID must be unique for each location', it, TargetplatformPackage.Literals.LOCATION__ID)
				]
				
				external.forEach[location |
					val includeErr = targetPlatform.includes.findFirst[
						val direct = indexBuilder.getImportedTargetPlatform(resource, it);
						direct.locations.contains(location) ||
						indexBuilder.getImportedTargetPlatforms(direct).map[locations].flatten.toSet.contains(location)
					]
					error('''ID '«duplicateID.ID»' is duplicated in the included target platform''', includeErr, TargetplatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI)
				]
			]]
		}
	}
	
	@Check
	def checkImportCycle(TargetPlatform targetPlatform) {
		val cycle = indexBuilder.checkIncludeCycle(targetPlatform)
		if (!cycle.empty) {
			val cyclingImport = targetPlatform.includes.findFirst[cycle.get(1).equals(indexBuilder.getImportedTargetPlatform(targetPlatform.eResource, it))]
			if (cyclingImport != null) {
				error('''Cycle detected in the included target platforms. Cycle is '«cycle.drop(1).map[eResource.URI].join("'' -> '")»'.''', 
					cyclingImport, 
					TargetplatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI
				)
			}
		}
	}
	
	@Check
	def checkImportedLocationConflictualID(TargetPlatform targetPlatform) {
		val index = indexBuilder.getLocationIndex(targetPlatform)
		val resource = targetPlatform.eResource
		
		for (locURI : index.keySet) {
			val externalLocations = index.get(locURI).filter[eResource != resource]
			val externalIDs = externalLocations.filter[ID!=null].map[ID].toSet
			
			val internalLocations = index.get(locURI).filter[eResource == resource]
			val internalIDs = internalLocations.filter[ID!=null].map[ID].toSet
			
			if (externalIDs.size > 1) {
				val externalLocationsWithConflictualID = externalLocations.filter[externalIDs.contains(ID)]
				val String msg = '''
					The ID for location '«locURI»' must be unique. Found '«externalIDs.join("', '")»'  in '«externalLocationsWithConflictualID.map[eResource.URI.toString].toSet.join("', '")»'.
				''';
				val resourcesURIWithLocationConflictualID = externalLocationsWithConflictualID.map[eResource.URI].toSet
				for (resourceURIWithLocationConflictualID : resourcesURIWithLocationConflictualID) {
					val includesError = targetPlatform.includes.filter[resourceURIWithLocationConflictualID.equals(URI.createURI(resolver.resolve(it)).resolve(resource.URI))]
					includesError.forEach[
						error(msg, it, TargetplatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI)
					]
				}
			}  

			if (externalIDs.size == 1) {
				val diff = Sets.symmetricDifference(externalIDs, internalIDs);
				if (!diff.empty) {
					val String msg = '''
						The ID for location '«locURI»' must be unique across included target platforms and the current one. Found '«externalIDs.head»'  in '«externalLocations.map[eResource.URI.toString].toSet.join("', '")»'.
					''';
					
					internalLocations.filter[ID != null && !externalIDs.contains(ID)].forEach[
						error(msg, it, TargetplatformPackage.Literals.LOCATION__ID, CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID, externalIDs.head, externalLocations.head.uri)
					]
				}
			} 
			
			if (externalIDs.size < 1 && internalIDs.size > 1) {
				val msg = '''The ID for location '«locURI»' must be unique. Found '«internalIDs.join("', '")»'.''';
				internalLocations.forEach[
					error(msg, it, TargetplatformPackage.Literals.LOCATION__ID, CHECK__LOCATION_CONFLICTUAL_ID)
				]
			}
		}
	}
}
