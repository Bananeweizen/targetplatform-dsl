/**
 * generated by Xtext
 */
package fr.obeo.releng.targetplatform.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.LinkedListMultimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.Sets;
import com.google.inject.Inject;
import fr.obeo.releng.targetplatform.IU;
import fr.obeo.releng.targetplatform.IncludeDeclaration;
import fr.obeo.releng.targetplatform.Location;
import fr.obeo.releng.targetplatform.Option;
import fr.obeo.releng.targetplatform.TargetPlatform;
import fr.obeo.releng.targetplatform.TargetPlatformPackage;
import fr.obeo.releng.targetplatform.util.LocationIndexBuilder;
import fr.obeo.releng.targetplatform.validation.AbstractTargetPlatformValidator;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.equinox.p2.core.IProvisioningAgent;
import org.eclipse.equinox.p2.metadata.IInstallableUnit;
import org.eclipse.equinox.p2.metadata.VersionRange;
import org.eclipse.equinox.p2.query.IQuery;
import org.eclipse.equinox.p2.query.IQueryResult;
import org.eclipse.equinox.p2.query.QueryUtil;
import org.eclipse.equinox.p2.repository.metadata.IMetadataRepository;
import org.eclipse.equinox.p2.repository.metadata.IMetadataRepositoryManager;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.AbstractRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.impl.CompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class TargetPlatformValidator extends AbstractTargetPlatformValidator {
  @Inject
  private LocationIndexBuilder indexBuilder;
  
  @Inject
  private IProvisioningAgent provisioningAgent;
  
  public final static String CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED = "CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED";
  
  public final static String CHECK__OPTIONS_EQUALS_ALL_LOCATIONS = "CHECK__OPTIONS_EQUALS_ALL_LOCATIONS";
  
  public final static String CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS = "CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS";
  
  public final static String DEPRECATE__OPTIONS_ON_LOCATIONS = "DEPRECATE__OPTIONS_ON_LOCATIONS";
  
  public final static String DEPRECATE__STRINGS_ON_IU_VERSION = "DEPRECATE__STRINGS_ON_IU_VERSION";
  
  public final static String CHECK__LOCATION_CONFLICTUAL_ID = "CHECK__LOCATION_CONFLICTUAL_ID";
  
  public final static String CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID = "CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID";
  
  public final static String CHECK__CONFLICTUAL_ID__BETWEEN_INCLUDED_LOCATION = "CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID";
  
  public final static String CHECK__LOCATION_ID_UNIQNESS = "CHECK__LOCATION_ID_UNIQNESS";
  
  public final static String CHECK__INCLUDE_CYCLE = "CHECK__INCLUDE_CYCLE";
  
  public final static String CHECK__IU_IN_LOCATION = "CHECK__IU_IN_LOCATION";
  
  public final static String CHECK__LOCATION_URI = "CHECK__LOCATION_URI";
  
  @Check
  public void checkAllEnvAndRequiredAreSelfExluding(final TargetPlatform targetPlatform) {
    EList<Option> _options = targetPlatform.getOptions();
    this.doCheckAllEnvAndRequiredAreSelfExluding(targetPlatform, _options, TargetPlatformPackage.Literals.TARGET_PLATFORM__OPTIONS);
  }
  
  @Check
  public void checkAllEnvAndRequiredAreSelfExluding(final Location location) {
    EList<Option> _options = location.getOptions();
    this.doCheckAllEnvAndRequiredAreSelfExluding(location, _options, TargetPlatformPackage.Literals.LOCATION__OPTIONS);
  }
  
  private void doCheckAllEnvAndRequiredAreSelfExluding(final EObject optionOwner, final List<Option> options, final EStructuralFeature feature) {
    boolean _and = false;
    boolean _contains = options.contains(Option.INCLUDE_ALL_ENVIRONMENTS);
    if (!_contains) {
      _and = false;
    } else {
      boolean _contains_1 = options.contains(Option.INCLUDE_REQUIRED);
      _and = _contains_1;
    }
    if (_and) {
      int _indexOf = options.indexOf(Option.INCLUDE_REQUIRED);
      this.error("All environments can not be included along with required artifacts, you must choose one of the two options.", optionOwner, feature, _indexOf, TargetPlatformValidator.CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED);
      int _indexOf_1 = options.indexOf(Option.INCLUDE_ALL_ENVIRONMENTS);
      this.error("All environments can not be included along with required artifacts, you must choose one of the two options.", optionOwner, feature, _indexOf_1, TargetPlatformValidator.CHECK__OPTIONS_SELF_EXCLUDING_ALL_ENV_REQUIRED);
    }
  }
  
  @Check
  public void checkNoLocationOptionIfGlobalOptions(final Location location) {
    boolean _and = false;
    EList<Option> _options = location.getOptions();
    boolean _isEmpty = _options.isEmpty();
    boolean _not = (!_isEmpty);
    if (!_not) {
      _and = false;
    } else {
      EObject _eContainer = location.eContainer();
      EList<Option> _options_1 = ((TargetPlatform) _eContainer).getOptions();
      boolean _isEmpty_1 = _options_1.isEmpty();
      boolean _not_1 = (!_isEmpty_1);
      _and = _not_1;
    }
    if (_and) {
      final List<INode> nodes = NodeModelUtils.findNodesForFeature(location, TargetPlatformPackage.Literals.LOCATION__OPTIONS);
      INode _head = IterableExtensions.<INode>head(nodes);
      final INode withKeyword = ((CompositeNode) _head).getPreviousSibling();
      INode _last = IterableExtensions.<INode>last(nodes);
      final CompositeNode lastOption = ((CompositeNode) _last);
      int _offset = withKeyword.getOffset();
      int _endOffset = lastOption.getEndOffset();
      int _offset_1 = withKeyword.getOffset();
      int _minus = (_endOffset - _offset_1);
      this.acceptError("You can not define options on location and on target platform.", location, _offset, _minus, TargetPlatformValidator.CHECK__NO_OPTIONS_ON_LOCATIONS_IF_GLOBAL_OPTIONS);
    }
  }
  
  @Check
  public void checkOptionsOnLocationAreIdentical(final TargetPlatform targetPlatform) {
    EList<Option> _options = targetPlatform.getOptions();
    boolean _isEmpty = _options.isEmpty();
    if (_isEmpty) {
      final EList<Location> listOptions = targetPlatform.getLocations();
      final Location first = IterableExtensions.<Location>head(listOptions);
      Iterable<Location> _tail = IterableExtensions.<Location>tail(listOptions);
      final Function1<Location, Boolean> _function = new Function1<Location, Boolean>() {
        public Boolean apply(final Location _) {
          EList<Option> _options = _.getOptions();
          Set<Option> _set = IterableExtensions.<Option>toSet(_options);
          EList<Option> _options_1 = first.getOptions();
          Set<Option> _set_1 = IterableExtensions.<Option>toSet(_options_1);
          Sets.SetView<Option> _symmetricDifference = Sets.<Option>symmetricDifference(_set, _set_1);
          boolean _isEmpty = _symmetricDifference.isEmpty();
          return Boolean.valueOf((!_isEmpty));
        }
      };
      final Iterable<Location> conflicts = IterableExtensions.<Location>filter(_tail, _function);
      boolean _isEmpty_1 = IterableExtensions.isEmpty(conflicts);
      boolean _not = (!_isEmpty_1);
      if (_not) {
        final Procedure1<Location> _function_1 = new Procedure1<Location>() {
          public void apply(final Location _) {
            final List<INode> nodes = NodeModelUtils.findNodesForFeature(_, TargetPlatformPackage.Literals.LOCATION__OPTIONS);
            boolean _isEmpty = nodes.isEmpty();
            boolean _not = (!_isEmpty);
            if (_not) {
              INode _head = IterableExtensions.<INode>head(nodes);
              final INode withKeyword = ((CompositeNode) _head).getPreviousSibling();
              INode _last = IterableExtensions.<INode>last(nodes);
              final CompositeNode lastOption = ((CompositeNode) _last);
              int _offset = withKeyword.getOffset();
              int _endOffset = lastOption.getEndOffset();
              int _offset_1 = withKeyword.getOffset();
              int _minus = (_endOffset - _offset_1);
              TargetPlatformValidator.this.acceptError("Options of every locations must be the same", _, _offset, _minus, TargetPlatformValidator.CHECK__OPTIONS_EQUALS_ALL_LOCATIONS);
            } else {
              final ICompositeNode node = NodeModelUtils.getNode(_);
              int _offset_2 = node.getOffset();
              int _length = node.getLength();
              TargetPlatformValidator.this.acceptError("Options of every locations must be the same", _, _offset_2, _length, TargetPlatformValidator.CHECK__OPTIONS_EQUALS_ALL_LOCATIONS);
            }
          }
        };
        IterableExtensions.<Location>forEach(listOptions, _function_1);
      }
    }
  }
  
  @Check
  public void deprecateOptionsOnLocation(final Location location) {
    EObject _eContainer = location.eContainer();
    final TargetPlatform targetPlatform = ((TargetPlatform) _eContainer);
    boolean _and = false;
    EList<Option> _options = targetPlatform.getOptions();
    boolean _isEmpty = _options.isEmpty();
    if (!_isEmpty) {
      _and = false;
    } else {
      EList<Option> _options_1 = location.getOptions();
      boolean _isEmpty_1 = _options_1.isEmpty();
      boolean _not = (!_isEmpty_1);
      _and = _not;
    }
    if (_and) {
      final List<INode> nodes = NodeModelUtils.findNodesForFeature(location, TargetPlatformPackage.Literals.LOCATION__OPTIONS);
      INode _head = IterableExtensions.<INode>head(nodes);
      final INode withKeyword = ((CompositeNode) _head).getPreviousSibling();
      INode _last = IterableExtensions.<INode>last(nodes);
      final CompositeNode lastOption = ((CompositeNode) _last);
      int _offset = withKeyword.getOffset();
      int _endOffset = lastOption.getEndOffset();
      int _offset_1 = withKeyword.getOffset();
      int _minus = (_endOffset - _offset_1);
      this.acceptWarning("Options on location are deprecated. Define the option at the target level.", location, _offset, _minus, TargetPlatformValidator.DEPRECATE__OPTIONS_ON_LOCATIONS);
    }
  }
  
  @Check
  public void deprecateIUVersionRangeWihString(final IU iu) {
    String _version = iu.getVersion();
    boolean _notEquals = (!Objects.equal(_version, null));
    if (_notEquals) {
      final List<INode> nodes = NodeModelUtils.findNodesForFeature(iu, TargetPlatformPackage.Literals.IU__VERSION);
      INode _head = IterableExtensions.<INode>head(nodes);
      EObject _grammarElement = _head.getGrammarElement();
      AbstractRule _rule = ((RuleCall) _grammarElement).getRule();
      String _name = _rule.getName();
      boolean _equals = "STRING".equals(_name);
      if (_equals) {
        this.warning("Usage of strings is deprecated for version range. You should remove the quotes.", iu, 
          TargetPlatformPackage.Literals.IU__VERSION, 
          TargetPlatformValidator.DEPRECATE__STRINGS_ON_IU_VERSION);
      }
    }
  }
  
  @Check
  public void checkIDUniqueOnAllLocations(final TargetPlatform targetPlatform) {
    final LinkedListMultimap<String, Location> locationsByURI = this.indexBuilder.getLocationIndex(targetPlatform);
    final Resource resource = targetPlatform.eResource();
    final LinkedHashMultimap<String, String> locationIDsByURI = LinkedHashMultimap.<String, String>create();
    Set<String> _keySet = locationsByURI.keySet();
    final Procedure1<String> _function = new Procedure1<String>() {
      public void apply(final String it) {
        List<Location> _get = locationsByURI.get(it);
        final Function1<Location, String> _function = new Function1<Location, String>() {
          public String apply(final Location it) {
            return it.getID();
          }
        };
        List<String> _map = ListExtensions.<Location, String>map(_get, _function);
        Set<String> _set = IterableExtensions.<String>toSet(_map);
        locationIDsByURI.putAll(it, _set);
      }
    };
    IterableExtensions.<String>forEach(_keySet, _function);
    Map<String, Collection<String>> _asMap = locationIDsByURI.asMap();
    final Function2<String, Collection<String>, Boolean> _function_1 = new Function2<String, Collection<String>, Boolean>() {
      public Boolean apply(final String key, final Collection<String> value) {
        int _size = value.size();
        return Boolean.valueOf((_size <= 1));
      }
    };
    Map<String, Collection<String>> _filter = MapExtensions.<String, Collection<String>>filter(_asMap, _function_1);
    final Set<String> locationsURIWithoutConflictingID = _filter.keySet();
    final Function1<String, List<Location>> _function_2 = new Function1<String, List<Location>>() {
      public List<Location> apply(final String it) {
        return locationsByURI.get(it);
      }
    };
    Iterable<List<Location>> _map = IterableExtensions.<String, List<Location>>map(locationsURIWithoutConflictingID, _function_2);
    final Iterable<Location> locationsWithoutConflictingID = Iterables.<Location>concat(_map);
    final Function1<Location, Boolean> _function_3 = new Function1<Location, Boolean>() {
      public Boolean apply(final Location it) {
        String _iD = it.getID();
        return Boolean.valueOf((!Objects.equal(_iD, null)));
      }
    };
    Iterable<Location> _filter_1 = IterableExtensions.<Location>filter(locationsWithoutConflictingID, _function_3);
    final Function<Location, String> _function_4 = new Function<Location, String>() {
      public String apply(final Location it) {
        return it.getID();
      }
    };
    final ImmutableListMultimap<String, Location> locationsWithoutConflictingIDByID = Multimaps.<String, Location>index(_filter_1, _function_4);
    ImmutableMap<String, Collection<Location>> _asMap_1 = locationsWithoutConflictingIDByID.asMap();
    final Function2<String, Collection<Location>, Boolean> _function_5 = new Function2<String, Collection<Location>, Boolean>() {
      public Boolean apply(final String key, final Collection<Location> value) {
        final Function1<Location, String> _function = new Function1<Location, String>() {
          public String apply(final Location it) {
            return it.getUri();
          }
        };
        Iterable<String> _map = IterableExtensions.<Location, String>map(value, _function);
        Set<String> _set = IterableExtensions.<String>toSet(_map);
        int _size = _set.size();
        return Boolean.valueOf((_size > 1));
      }
    };
    Map<String, Collection<Location>> _filter_2 = MapExtensions.<String, Collection<Location>>filter(_asMap_1, _function_5);
    Collection<Collection<Location>> _values = _filter_2.values();
    final Iterable<Location> locationsWithDuplicateID = Iterables.<Location>concat(_values);
    final Procedure1<Location> _function_6 = new Procedure1<Location>() {
      public void apply(final Location location) {
        Resource _eResource = location.eResource();
        boolean _equals = Objects.equal(_eResource, resource);
        if (_equals) {
          TargetPlatformValidator.this.error("ID must be unique for each location", location, 
            TargetPlatformPackage.Literals.LOCATION__ID, 
            TargetPlatformValidator.CHECK__LOCATION_ID_UNIQNESS);
        } else {
          EList<IncludeDeclaration> _includes = targetPlatform.getIncludes();
          final Function1<IncludeDeclaration, Boolean> _function = new Function1<IncludeDeclaration, Boolean>() {
            public Boolean apply(final IncludeDeclaration it) {
              boolean _xblockexpression = false;
              {
                final TargetPlatform direct = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatform(resource, it);
                boolean _or = false;
                EList<Location> _locations = direct.getLocations();
                boolean _contains = _locations.contains(location);
                if (_contains) {
                  _or = true;
                } else {
                  LinkedList<TargetPlatform> _importedTargetPlatforms = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatforms(direct);
                  final Function1<TargetPlatform, EList<Location>> _function = new Function1<TargetPlatform, EList<Location>>() {
                    public EList<Location> apply(final TargetPlatform it) {
                      return it.getLocations();
                    }
                  };
                  List<EList<Location>> _map = ListExtensions.<TargetPlatform, EList<Location>>map(_importedTargetPlatforms, _function);
                  Iterable<Location> _flatten = Iterables.<Location>concat(_map);
                  Set<Location> _set = IterableExtensions.<Location>toSet(_flatten);
                  boolean _contains_1 = _set.contains(location);
                  _or = _contains_1;
                }
                _xblockexpression = _or;
              }
              return Boolean.valueOf(_xblockexpression);
            }
          };
          Iterable<IncludeDeclaration> _filter = IterableExtensions.<IncludeDeclaration>filter(_includes, _function);
          final Set<IncludeDeclaration> conflictualInclude = IterableExtensions.<IncludeDeclaration>toSet(_filter);
          final Procedure1<IncludeDeclaration> _function_1 = new Procedure1<IncludeDeclaration>() {
            public void apply(final IncludeDeclaration it) {
              StringConcatenation _builder = new StringConcatenation();
              _builder.append("ID \'");
              String _iD = location.getID();
              _builder.append(_iD, "");
              _builder.append("\' is duplicated in the included target platform");
              TargetPlatformValidator.this.error(_builder.toString(), it, 
                TargetPlatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI, 
                TargetPlatformValidator.CHECK__LOCATION_ID_UNIQNESS);
            }
          };
          IterableExtensions.<IncludeDeclaration>forEach(conflictualInclude, _function_1);
        }
      }
    };
    IterableExtensions.<Location>forEach(locationsWithDuplicateID, _function_6);
  }
  
  @Check
  public void checkImportCycle(final TargetPlatform targetPlatform) {
    final List<TargetPlatform> cycle = this.indexBuilder.checkIncludeCycle(targetPlatform);
    boolean _isEmpty = cycle.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      EList<IncludeDeclaration> _includes = targetPlatform.getIncludes();
      final Function1<IncludeDeclaration, Boolean> _function = new Function1<IncludeDeclaration, Boolean>() {
        public Boolean apply(final IncludeDeclaration it) {
          TargetPlatform _get = cycle.get(1);
          Resource _eResource = targetPlatform.eResource();
          TargetPlatform _importedTargetPlatform = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatform(_eResource, it);
          return Boolean.valueOf(_get.equals(_importedTargetPlatform));
        }
      };
      final IncludeDeclaration cyclingImport = IterableExtensions.<IncludeDeclaration>findFirst(_includes, _function);
      boolean _notEquals = (!Objects.equal(cyclingImport, null));
      if (_notEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Cycle detected in the included target platforms. Cycle is \'");
        Iterable<TargetPlatform> _drop = IterableExtensions.<TargetPlatform>drop(cycle, 1);
        final Function1<TargetPlatform, URI> _function_1 = new Function1<TargetPlatform, URI>() {
          public URI apply(final TargetPlatform it) {
            Resource _eResource = it.eResource();
            return _eResource.getURI();
          }
        };
        Iterable<URI> _map = IterableExtensions.<TargetPlatform, URI>map(_drop, _function_1);
        String _join = IterableExtensions.join(_map, "\'\' -> \'");
        _builder.append(_join, "");
        _builder.append("\'.");
        this.error(_builder.toString(), cyclingImport, 
          TargetPlatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI, 
          TargetPlatformValidator.CHECK__INCLUDE_CYCLE);
      }
    }
  }
  
  @Check
  public void checkSameIDForAllLocationWithSameURI(final TargetPlatform targetPlatform) {
    final LinkedListMultimap<String, Location> locationsByURI = this.indexBuilder.getLocationIndex(targetPlatform);
    final Resource resource = targetPlatform.eResource();
    Set<String> _keySet = locationsByURI.keySet();
    for (final String locationURI : _keySet) {
      {
        List<Location> _get = locationsByURI.get(locationURI);
        final Function1<Location, Boolean> _function = new Function1<Location, Boolean>() {
          public Boolean apply(final Location it) {
            Resource _eResource = it.eResource();
            return Boolean.valueOf((!Objects.equal(_eResource, resource)));
          }
        };
        final Iterable<Location> externalLocations = IterableExtensions.<Location>filter(_get, _function);
        final Function1<Location, String> _function_1 = new Function1<Location, String>() {
          public String apply(final Location it) {
            String _iD = it.getID();
            return Strings.nullToEmpty(_iD);
          }
        };
        Iterable<String> _map = IterableExtensions.<Location, String>map(externalLocations, _function_1);
        final Set<String> externalIDs = IterableExtensions.<String>toSet(_map);
        List<Location> _get_1 = locationsByURI.get(locationURI);
        final Function1<Location, Boolean> _function_2 = new Function1<Location, Boolean>() {
          public Boolean apply(final Location it) {
            Resource _eResource = it.eResource();
            return Boolean.valueOf(Objects.equal(_eResource, resource));
          }
        };
        final Iterable<Location> internalLocations = IterableExtensions.<Location>filter(_get_1, _function_2);
        final Function1<Location, String> _function_3 = new Function1<Location, String>() {
          public String apply(final Location it) {
            String _iD = it.getID();
            return Strings.nullToEmpty(_iD);
          }
        };
        Iterable<String> _map_1 = IterableExtensions.<Location, String>map(internalLocations, _function_3);
        final Set<String> internalIDs = IterableExtensions.<String>toSet(_map_1);
        int _size = externalIDs.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          final Function1<Location, Boolean> _function_4 = new Function1<Location, Boolean>() {
            public Boolean apply(final Location it) {
              String _iD = it.getID();
              return Boolean.valueOf(externalIDs.contains(_iD));
            }
          };
          final Iterable<Location> externalLocationsWithConflictualID = IterableExtensions.<Location>filter(externalLocations, _function_4);
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The ID for location \'");
          _builder.append(locationURI, "");
          _builder.append("\' must be unique. Found \'");
          String _join = IterableExtensions.join(externalIDs, "\', \'");
          _builder.append(_join, "");
          _builder.append("\'  in \'");
          final Function1<Location, String> _function_5 = new Function1<Location, String>() {
            public String apply(final Location it) {
              Resource _eResource = it.eResource();
              URI _uRI = _eResource.getURI();
              return _uRI.toString();
            }
          };
          Iterable<String> _map_2 = IterableExtensions.<Location, String>map(externalLocationsWithConflictualID, _function_5);
          Set<String> _set = IterableExtensions.<String>toSet(_map_2);
          String _join_1 = IterableExtensions.join(_set, "\', \'");
          _builder.append(_join_1, "");
          _builder.append("\'.");
          _builder.newLineIfNotEmpty();
          final String msg = _builder.toString();
          final Function1<Location, Iterable<IncludeDeclaration>> _function_6 = new Function1<Location, Iterable<IncludeDeclaration>>() {
            public Iterable<IncludeDeclaration> apply(final Location location) {
              EList<IncludeDeclaration> _includes = targetPlatform.getIncludes();
              final Function1<IncludeDeclaration, Boolean> _function = new Function1<IncludeDeclaration, Boolean>() {
                public Boolean apply(final IncludeDeclaration it) {
                  boolean _xblockexpression = false;
                  {
                    final TargetPlatform direct = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatform(resource, it);
                    boolean _or = false;
                    EList<Location> _locations = direct.getLocations();
                    boolean _contains = _locations.contains(location);
                    if (_contains) {
                      _or = true;
                    } else {
                      LinkedList<TargetPlatform> _importedTargetPlatforms = TargetPlatformValidator.this.indexBuilder.getImportedTargetPlatforms(direct);
                      final Function1<TargetPlatform, EList<Location>> _function = new Function1<TargetPlatform, EList<Location>>() {
                        public EList<Location> apply(final TargetPlatform it) {
                          return it.getLocations();
                        }
                      };
                      List<EList<Location>> _map = ListExtensions.<TargetPlatform, EList<Location>>map(_importedTargetPlatforms, _function);
                      Iterable<Location> _flatten = Iterables.<Location>concat(_map);
                      Set<Location> _set = IterableExtensions.<Location>toSet(_flatten);
                      boolean _contains_1 = _set.contains(location);
                      _or = _contains_1;
                    }
                    _xblockexpression = _or;
                  }
                  return Boolean.valueOf(_xblockexpression);
                }
              };
              return IterableExtensions.<IncludeDeclaration>filter(_includes, _function);
            }
          };
          Iterable<Iterable<IncludeDeclaration>> _map_3 = IterableExtensions.<Location, Iterable<IncludeDeclaration>>map(externalLocationsWithConflictualID, _function_6);
          Iterable<IncludeDeclaration> _flatten = Iterables.<IncludeDeclaration>concat(_map_3);
          final Set<IncludeDeclaration> conflictualInclude = IterableExtensions.<IncludeDeclaration>toSet(_flatten);
          final Procedure1<IncludeDeclaration> _function_7 = new Procedure1<IncludeDeclaration>() {
            public void apply(final IncludeDeclaration it) {
              TargetPlatformValidator.this.error(msg, it, 
                TargetPlatformPackage.Literals.INCLUDE_DECLARATION__IMPORT_URI, 
                TargetPlatformValidator.CHECK__CONFLICTUAL_ID__BETWEEN_INCLUDED_LOCATION);
            }
          };
          IterableExtensions.<IncludeDeclaration>forEach(conflictualInclude, _function_7);
        }
        int _size_1 = externalIDs.size();
        boolean _equals = (_size_1 == 1);
        if (_equals) {
          final Sets.SetView<String> diff = Sets.<String>symmetricDifference(externalIDs, internalIDs);
          boolean _isEmpty = diff.isEmpty();
          boolean _not = (!_isEmpty);
          if (_not) {
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("The ID for location \'");
            _builder_1.append(locationURI, "");
            _builder_1.append("\' must be unique across included target platforms and the current one. Found \'");
            String _head = IterableExtensions.<String>head(externalIDs);
            _builder_1.append(_head, "");
            _builder_1.append("\'  in \'");
            final Function1<Location, String> _function_8 = new Function1<Location, String>() {
              public String apply(final Location it) {
                Resource _eResource = it.eResource();
                URI _uRI = _eResource.getURI();
                return _uRI.toString();
              }
            };
            Iterable<String> _map_4 = IterableExtensions.<Location, String>map(externalLocations, _function_8);
            Set<String> _set_1 = IterableExtensions.<String>toSet(_map_4);
            String _join_2 = IterableExtensions.join(_set_1, "\', \'");
            _builder_1.append(_join_2, "");
            _builder_1.append("\'.");
            _builder_1.newLineIfNotEmpty();
            final String msg_1 = _builder_1.toString();
            final Function1<Location, Boolean> _function_9 = new Function1<Location, Boolean>() {
              public Boolean apply(final Location it) {
                String _iD = it.getID();
                String _nullToEmpty = Strings.nullToEmpty(_iD);
                boolean _contains = externalIDs.contains(_nullToEmpty);
                return Boolean.valueOf((!_contains));
              }
            };
            Iterable<Location> _filter = IterableExtensions.<Location>filter(internalLocations, _function_9);
            final Procedure1<Location> _function_10 = new Procedure1<Location>() {
              public void apply(final Location it) {
                String _head = IterableExtensions.<String>head(externalIDs);
                Location _head_1 = IterableExtensions.<Location>head(externalLocations);
                String _uri = _head_1.getUri();
                TargetPlatformValidator.this.error(msg_1, it, TargetPlatformPackage.Literals.LOCATION__ID, TargetPlatformValidator.CHECK__INCLUDED_LOCATION_CONFLICTUAL_ID, _head, _uri);
              }
            };
            IterableExtensions.<Location>forEach(_filter, _function_10);
          }
        }
        boolean _and = false;
        int _size_2 = externalIDs.size();
        boolean _lessThan = (_size_2 < 1);
        if (!_lessThan) {
          _and = false;
        } else {
          int _size_3 = internalIDs.size();
          boolean _greaterThan_1 = (_size_3 > 1);
          _and = _greaterThan_1;
        }
        if (_and) {
          StringConcatenation _builder_2 = new StringConcatenation();
          _builder_2.append("The ID for location \'");
          _builder_2.append(locationURI, "");
          _builder_2.append("\' must be unique. Found \'");
          String _join_3 = IterableExtensions.join(internalIDs, "\', \'");
          _builder_2.append(_join_3, "");
          _builder_2.append("\'.");
          final String msg_2 = _builder_2.toString();
          final Procedure1<Location> _function_11 = new Procedure1<Location>() {
            public void apply(final Location it) {
              TargetPlatformValidator.this.error(msg_2, it, TargetPlatformPackage.Literals.LOCATION__ID, TargetPlatformValidator.CHECK__LOCATION_CONFLICTUAL_ID);
            }
          };
          IterableExtensions.<Location>forEach(internalLocations, _function_11);
        }
      }
    }
  }
  
  @Check(value = CheckType.EXPENSIVE)
  public IMetadataRepository checkLocationURI(final Location location) {
    IMetadataRepository _xifexpression = null;
    String _uri = location.getUri();
    boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_uri);
    boolean _not = (!_isNullOrEmpty);
    if (_not) {
      IMetadataRepository _xblockexpression = null;
      {
        Object _service = this.provisioningAgent.getService(IMetadataRepositoryManager.SERVICE_NAME);
        final IMetadataRepositoryManager repositoryManager = ((IMetadataRepositoryManager) _service);
        IMetadataRepository _xtrycatchfinallyexpression = null;
        try {
          String _uri_1 = location.getUri();
          java.net.URI _uRI = new java.net.URI(_uri_1);
          NullProgressMonitor _nullProgressMonitor = new NullProgressMonitor();
          _xtrycatchfinallyexpression = repositoryManager.loadRepository(_uRI, _nullProgressMonitor);
        } catch (final Throwable _t) {
          if (_t instanceof Exception) {
            final Exception e = (Exception)_t;
            String _message = e.getMessage();
            this.error(_message, location, TargetPlatformPackage.Literals.LOCATION__URI, TargetPlatformValidator.CHECK__LOCATION_URI);
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
        _xblockexpression = _xtrycatchfinallyexpression;
      }
      _xifexpression = _xblockexpression;
    }
    return _xifexpression;
  }
  
  @Check(value = CheckType.EXPENSIVE)
  public void checkIUIDAndRangeInRepository(final IU iu) {
    try {
      Object _service = this.provisioningAgent.getService(IMetadataRepositoryManager.SERVICE_NAME);
      final IMetadataRepositoryManager repositoryManager = ((IMetadataRepositoryManager) _service);
      EObject _eContainer = iu.eContainer();
      String _uri = ((Location) _eContainer).getUri();
      java.net.URI _uRI = new java.net.URI(_uri);
      NullProgressMonitor _nullProgressMonitor = new NullProgressMonitor();
      final IMetadataRepository metadataRepository = repositoryManager.loadRepository(_uRI, _nullProgressMonitor);
      String _iD = iu.getID();
      IQuery<IInstallableUnit> _createIUQuery = QueryUtil.createIUQuery(_iD);
      NullProgressMonitor _nullProgressMonitor_1 = new NullProgressMonitor();
      IQueryResult<IInstallableUnit> _query = metadataRepository.query(_createIUQuery, _nullProgressMonitor_1);
      final Set<IInstallableUnit> idResults = _query.toUnmodifiableSet();
      boolean _isEmpty = idResults.isEmpty();
      if (_isEmpty) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("No installable unit with ID \'");
        String _iD_1 = iu.getID();
        _builder.append(_iD_1, "");
        _builder.append("\' can be found in \'");
        EObject _eContainer_1 = iu.eContainer();
        String _uri_1 = ((Location) _eContainer_1).getUri();
        _builder.append(_uri_1, "");
        _builder.append("\'.");
        this.error(_builder.toString(), iu, TargetPlatformPackage.Literals.IU__ID, TargetPlatformValidator.CHECK__IU_IN_LOCATION);
      } else {
        boolean _and = false;
        String _version = iu.getVersion();
        boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_version);
        boolean _not = (!_isNullOrEmpty);
        if (!_not) {
          _and = false;
        } else {
          String _version_1 = iu.getVersion();
          boolean _equals = "lazy".equals(_version_1);
          boolean _not_1 = (!_equals);
          _and = _not_1;
        }
        if (_and) {
          String _iD_2 = iu.getID();
          String _version_2 = iu.getVersion();
          VersionRange _versionRange = new VersionRange(_version_2);
          IQuery<IInstallableUnit> _createQuery = QueryUtil.createQuery("latest(x | x.id == $0 && x.version ~= $1)", _iD_2, _versionRange);
          NullProgressMonitor _nullProgressMonitor_2 = new NullProgressMonitor();
          final IQueryResult<IInstallableUnit> versionResult = metadataRepository.query(_createQuery, _nullProgressMonitor_2);
          boolean _isEmpty_1 = versionResult.isEmpty();
          if (_isEmpty_1) {
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("No installable unit with ID \'");
            String _iD_3 = iu.getID();
            _builder_1.append(_iD_3, "");
            _builder_1.append("\' can be found with range constraint \'");
            String _version_3 = iu.getVersion();
            _builder_1.append(_version_3, "");
            _builder_1.append("\'.");
            this.error(_builder_1.toString(), iu, TargetPlatformPackage.Literals.IU__VERSION, TargetPlatformValidator.CHECK__IU_IN_LOCATION);
          }
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
